; dl_oracle.clsp
; for DataLayer.storage by yakuhito

;; Allows anyone to spend the DL store and use it as an oracle. Because this
;; layer cannot be updated, it supports any metadata updater and metadata as
;; long as (f metadata) item is the root hash.
;;
;; Note: This layer cannot be removed/exited - once added, any announcement
;;       starting with 'o' that is 33-bytes-long is made from the oracle layer. 
;;
;; Warning: The owner still controls which puzzles are whitelisted to run, and
;;          the oracle functionality can be disabled by setting an unreasonable
;;          oracle fee.

(mod (
    ; first curry
    SINGLETON_STRUCT
    STATE_LAYER_MOD_HASH
    ; second curry
    SELF_HASH
    ORACLE_CONFIG
      ; (ORACLE_CONDITION . AUTHORIZED_ORACLE_PUZZLES)
      ; where ORACLE_CONDITION = (list CREATE_COIN [oracle fee payment address] [oracle fee])
      ; and AUTHORIZED_ORACLE_PUZZLES = (list [oracle puzzle hash 1] [oracle puzzle hash 2] ...)
    INNER_PUZZLE_HASH
    oracle_config_reveal
    metadata_reveal
    puzzle_reveal ; metadata updater reveal
    state_layer_puzzle_hash
  )

  (include condition_codes.clib)
  (include sha256tree.clib)
  (include curry.clib)

  (defconstant NEW_ORACLE_CONFIG_CONDITION -13)
  (defconstant ANNOUNCEMENT_PREFIX 'o')

  (defun morph_conditions (SELF_HASH ORACLE_CONFIG conditions odd_create_coin_args optional_new_oracle_config)
    (if conditions
      (if (all (= optional_new_oracle_config ()) (= (f (f conditions)) NEW_ORACLE_CONFIG_CONDITION))
        (morph_conditions SELF_HASH ORACLE_CONFIG (r conditions) odd_create_coin_args (r (f conditions)))
        ; else
        (if (all (= (f (f conditions)) CREATE_COIN) (= (logand (f (r (r (f conditions)))) 1) 1))
          (morph_conditions SELF_HASH ORACLE_CONFIG (r conditions) (r (f conditions)) optional_new_oracle_config)
          ; else
          (c (f conditions)
            (morph_conditions SELF_HASH ORACLE_CONFIG (r conditions) odd_create_coin_args optional_new_oracle_config)
          )
        )
      )
      ; else
      (list
        (list
          CREATE_COIN
          (curry_hashes SELF_HASH
            (sha256 1 SELF_HASH)
            (sha256 1
              (if optional_new_oracle_config
                (sha256tree optional_new_oracle_config) ; reveal new config on-chain
                ; else
                ORACLE_CONFIG
              )
            )
            (sha256 1 (f odd_create_coin_args)) ; inner puzzle hash
          ) ; wrap inner puzzle with this layer
          (r odd_create_coin_args)
        )
      )
    )
  )

  ; oracle spend
  (list
    ; check that metadata & updater are correct
    (list
      ASSERT_MY_PUZZLEHASH
      (curry_hashes (f SINGLETON_STRUCT)
        (sha256tree SINGLETON_STRUCT)
        (curry_hashes STATE_LAYER_MOD_HASH
          (sha256 1 STATE_LAYER_MOD_HASH)
          (sha256tree metadata_reveal)
          (sha256tree puzzle_reveal)
          state_layer_puzzle_hash
        )
      )
    )
    (f oracle_config_reveal) ; payment cond
  )
)
